--// ====== SETTINGS ======
local RENDERED_FOLDER_NAME = "RenderedMovingAnimals"

--// ====== LOAD ANIMALS DB ======
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local AnimalsModule = require(ReplicatedStorage:WaitForChild("Datas"):WaitForChild("Animals"))

-- AnimalsModule is expected to be a table like:
-- ["Noobini Pizzanini"] = { DisplayName="Noobini Pizzanini"; Rarity="Common"; Price=25; Generation=1; RoadWeight=100; }
-- We will normalize it into a list we can iterate & sort.
local Brainrots = {}
for key, data in pairs(AnimalsModule) do
	if typeof(data) == "table" then
		table.insert(Brainrots, {
			Key = key,
			DisplayName = data.DisplayName or key,
			Rarity = data.Rarity,
			Price = tonumber(data.Price) or 0,
			Generation = tonumber(data.Generation) or 0,
			RoadWeight = data.RoadWeight
		})
	end
end
table.sort(Brainrots, function(a,b) return tostring(a.DisplayName) < tostring(b.DisplayName) end)

-- Fast lookup by DisplayName and by Key
local ByDisplay = {}
local ByKey = {}
for _, br in ipairs(Brainrots) do
	ByDisplay[br.DisplayName] = br
	ByKey[br.Key] = br
end

--// ====== MAIN GUI ======
local gui = Instance.new("ScreenGui")
gui.Name = "AnimalInfoDisplay"
gui.ResetOnSpawn = false
gui.Parent = game:GetService("CoreGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 340, 0, 560)
frame.Position = UDim2.new(0.5, -170, 0.5, -280)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Active = true
frame.Parent = gui

-- ===== DRAGGING =====
local UIS = game:GetService("UserInputService")
local dragging, dragStart, startPos
local function onInputBegan(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
	end
end
local function onInputChanged(input, gpe)
	if gpe then return end
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end
local function onInputEnded(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = false
	end
end
frame.InputBegan:Connect(onInputBegan)
frame.InputChanged:Connect(onInputChanged)
frame.InputEnded:Connect(onInputEnded)

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -30, 0, 30)
title.Position = UDim2.new(0, 10, 0, 6)
title.BackgroundTransparency = 1
title.Text = "Rendered Moving Animals"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = frame
title.InputBegan:Connect(onInputBegan)
title.InputChanged:Connect(onInputChanged)
title.InputEnded:Connect(onInputEnded)

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 20, 0, 20)
closeBtn.Position = UDim2.new(1, -25, 0, 5)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.Font = Enum.Font.SourceSansBold
closeBtn.TextSize = 14
closeBtn.Parent = frame
closeBtn.MouseButton1Click:Connect(function() gui:Destroy() end)

-- Keybind row
local keyRow = Instance.new("Frame")
keyRow.Size = UDim2.new(1, -20, 0, 24)
keyRow.Position = UDim2.new(0, 10, 0, 40)
keyRow.BackgroundTransparency = 1
keyRow.Parent = frame

local keyLbl = Instance.new("TextLabel")
keyLbl.Size = UDim2.new(0, 90, 1, 0)
keyLbl.BackgroundTransparency = 1
keyLbl.Text = "Toggle key:"
keyLbl.TextColor3 = Color3.new(1, 1, 1)
keyLbl.Font = Enum.Font.SourceSans
keyLbl.TextSize = 14
keyLbl.TextXAlignment = Enum.TextXAlignment.Left
keyLbl.Parent = keyRow

local keyBox = Instance.new("TextBox")
keyBox.Size = UDim2.new(1, -95, 1, 0)
keyBox.Position = UDim2.new(0, 95, 0, 0)
keyBox.PlaceholderText = "e.g. RightShift, P, F4"
keyBox.Text = "RightShift"
keyBox.TextColor3 = Color3.new(0, 0, 0)
keyBox.Font = Enum.Font.SourceSans
keyBox.TextSize = 14
keyBox.Parent = keyRow

-- Auto-walk & buy toggle
local autoBtn = Instance.new("TextButton")
autoBtn.Size = UDim2.new(1, -20, 0, 24)
autoBtn.Position = UDim2.new(0, 10, 0, 70)
autoBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
autoBtn.TextColor3 = Color3.new(1, 1, 1)
autoBtn.Font = Enum.Font.SourceSansBold
autoBtn.TextSize = 14
autoBtn.Text = "Auto-walk & buy: ON"
autoBtn.Parent = frame
local autoEnabled = true
autoBtn.MouseButton1Click:Connect(function()
	autoEnabled = not autoEnabled
	autoBtn.Text = "Auto-walk & buy: " .. (autoEnabled and "ON" or "OFF")
end)

-- Warning label
local warningLabel = Instance.new("TextLabel")
warningLabel.Size = UDim2.new(1, -20, 0, 18)
warningLabel.Position = UDim2.new(0, 10, 0, 98)
warningLabel.BackgroundTransparency = 1
warningLabel.Text = ""
warningLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
warningLabel.Font = Enum.Font.SourceSansBold
warningLabel.TextSize = 16
warningLabel.Visible = false
warningLabel.Parent = frame

-- ===== FILTER HEADER & MODE =====
local filterHeader = Instance.new("TextLabel")
filterHeader.Size = UDim2.new(1, -20, 0, 22)
filterHeader.Position = UDim2.new(0, 10, 0, 120)
filterHeader.BackgroundTransparency = 1
filterHeader.Text = "Chase by:"
filterHeader.TextColor3 = Color3.new(1, 1, 1)
filterHeader.Font = Enum.Font.SourceSansBold
filterHeader.TextSize = 16
filterHeader.TextXAlignment = Enum.TextXAlignment.Left
filterHeader.Parent = frame

local modes = {"Display Name","Price ≥","Generation ≥"}
local currentModeIndex = 1

local modeBtn = Instance.new("TextButton")
modeBtn.Size = UDim2.new(1, -20, 0, 26)
modeBtn.Position = UDim2.new(0, 10, 0, 145)
modeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
modeBtn.TextColor3 = Color3.new(1, 1, 1)
modeBtn.Font = Enum.Font.SourceSansBold
modeBtn.TextSize = 14
modeBtn.Text = "Mode: " .. modes[currentModeIndex]
modeBtn.Parent = frame

-- ===== INPUTS PER MODE =====

-- DisplayName cycler
local nameIndex = 1
local nameBtn = Instance.new("TextButton")
nameBtn.Size = UDim2.new(1, -20, 0, 24)
nameBtn.Position = UDim2.new(0, 10, 0, 175)
nameBtn.BackgroundColor3 = Color3.fromRGB(60,60,60)
nameBtn.TextColor3 = Color3.new(1,1,1)
nameBtn.Font = Enum.Font.SourceSans
nameBtn.TextSize = 14
nameBtn.Text = (#Brainrots > 0) and ("Display: " .. Brainrots[nameIndex].DisplayName) or "No brainrots"
nameBtn.Parent = frame
nameBtn.MouseButton1Click:Connect(function()
	if #Brainrots == 0 then return end
	nameIndex = nameIndex % #Brainrots + 1
	nameBtn.Text = "Display: " .. Brainrots[nameIndex].DisplayName
	updateDisplay()
end)

-- Price ≥ threshold
local priceRow = Instance.new("Frame")
priceRow.Size = UDim2.new(1, -20, 0, 24)
priceRow.Position = UDim2.new(0, 10, 0, 175)
priceRow.BackgroundTransparency = 1
priceRow.Parent = frame

local priceMin = Instance.new("TextBox")
priceMin.Size = UDim2.new(1, 0, 1, 0)
priceMin.PlaceholderText = "Enter minimum Price (≥)"
priceMin.Text = ""
priceMin.TextColor3 = Color3.new(0,0,0)
priceMin.Font = Enum.Font.SourceSans
priceMin.TextSize = 14
priceMin.Parent = priceRow

-- Generation ≥ threshold
local genRow = Instance.new("Frame")
genRow.Size = UDim2.new(1, -20, 0, 24)
genRow.Position = UDim2.new(0, 10, 0, 175)
genRow.BackgroundTransparency = 1
genRow.Parent = frame

local genMin = Instance.new("TextBox")
genMin.Size = UDim2.new(1, 0, 1, 0)
genMin.PlaceholderText = "Enter minimum Generation (≥)"
genMin.Text = ""
genMin.TextColor3 = Color3.new(0,0,0)
genMin.Font = Enum.Font.SourceSans
genMin.TextSize = 14
genMin.Parent = genRow

-- Find & lock button
local findBtn = Instance.new("TextButton")
findBtn.Size = UDim2.new(1, -20, 0, 26)
findBtn.Position = UDim2.new(0, 10, 0, 205)
findBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
findBtn.TextColor3 = Color3.new(1, 1, 1)
findBtn.Font = Enum.Font.SourceSansBold
findBtn.TextSize = 14
findBtn.Text = "Find & Lock Nearest Match"
findBtn.Parent = frame

-- Scroll list (matches)
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -20, 1, -265)
scrollFrame.Position = UDim2.new(0, 10, 0, 235)
scrollFrame.BackgroundTransparency = 1
scrollFrame.ScrollBarThickness = 6
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.Parent = frame

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 5)
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Parent = scrollFrame

-- Mode switching updates visible inputs
local function updateInputsVisibility()
	local mode = modes[currentModeIndex]
	nameBtn.Visible = (mode == "Display Name")
	priceRow.Visible = (mode == "Price ≥")
	genRow.Visible   = (mode == "Generation ≥")
end
modeBtn.MouseButton1Click:Connect(function()
	currentModeIndex = currentModeIndex % #modes + 1
	modeBtn.Text = "Mode: " .. modes[currentModeIndex]
	updateInputsVisibility()
	updateDisplay()
end)
updateInputsVisibility()

-- ===== KEYBIND TOGGLE =====
local currentKeyCode = Enum.KeyCode.RightShift
local function parseKeyCode(txt)
	if Enum.KeyCode[txt] then return Enum.KeyCode[txt] end
	local upper = string.upper(txt)
	if Enum.KeyCode[upper] then return Enum.KeyCode[upper] end
	return nil
end
keyBox.FocusLost:Connect(function()
	local code = parseKeyCode(keyBox.Text)
	if code then
		currentKeyCode = code
		keyBox.TextColor3 = Color3.new(0, 0.4, 0)
	else
		keyBox.TextColor3 = Color3.fromRGB(200, 0, 0)
	end
end)
UIS.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if UIS:GetFocusedTextBox() then return end
	if input.KeyCode == currentKeyCode then
		gui.Enabled = not gui.Enabled
	end
end)

-- ===== CORE: pathfinding & prompts =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local VIM = game:GetService("VirtualInputManager")

local localPlayer = Players.LocalPlayer
local function getCharParts()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")
	return char, hrp, hum
end

local holdingE = false
local function holdE(seconds)
	if holdingE then return end
	holdingE = true
	pcall(function()
		VIM:SendKeyEvent(true, Enum.KeyCode.E, false, nil)
		task.wait(seconds or 4.05)
		VIM:SendKeyEvent(false, Enum.KeyCode.E, false, nil)
	end)
	holdingE = false
end

local function triggerNearbyPrompt(maxRadius)
	local _, hrp = getCharParts()
	if not hrp then return end
	local radius = maxRadius or 15
	for _, d in ipairs(workspace:GetDescendants()) do
		if d:IsA("ProximityPrompt") then
			local adornee = d.Parent
			local part = adornee and (adornee:IsA("BasePart") and adornee or adornee:FindFirstChildOfClass("BasePart"))
			if part and (part.Position - hrp.Position).Magnitude <= radius then
				pcall(function() fireproximityprompt(d) end)
			end
		end
	end
end

-- Pathfinding (repath)
local path = PathfindingService:CreatePath({
	AgentRadius = 2,
	AgentHeight = 5,
	AgentCanJump = true
})
local lastPathTime = 0
local lastTarget
local function moveToTarget(targetModel)
	local _, hrp, hum = getCharParts()
	if not hrp or not hum or not targetModel or not targetModel.Parent then return end
	if not targetModel.PrimaryPart then return end
	local now = tick()
	if now - lastPathTime < 0.75 then return end
	lastPathTime = now
	local targetPos = targetModel.PrimaryPart.Position
	local ok = pcall(function() path:ComputeAsync(hrp.Position, targetPos) end)
	if not ok then return end
	if path.Status ~= Enum.PathStatus.Success then
		hum:MoveTo(targetPos)
		return
	end
	for _, wp in ipairs(path:GetWaypoints()) do
		if not targetModel.Parent or not gui.Enabled or not autoEnabled then break end
		if wp.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end
		hum:MoveTo(wp.Position)
		hum.MoveToFinished:Wait()
	end
end

-- ===== MATCHING / FILTERING =====
local function getAnimalsFolder()
	return workspace:FindFirstChild(RENDERED_FOLDER_NAME)
end

local function nearestOf(list)
	local _, hrp = getCharParts()
	if not hrp then return nil end
	local best, bestDist
	for _, m in ipairs(list) do
		if m.PrimaryPart then
			local d = (m.PrimaryPart.Position - hrp.Position).Magnitude
			if not bestDist or d < bestDist then
				best, bestDist = m, d
			end
		end
	end
	return best
end

-- Returns the Brainrot data by model.Name (tries DisplayName first, then key)
local function getDataForModel(modelName)
	return ByDisplay[modelName] or ByKey[modelName]
end

local function collectMatches()
	local folder = getAnimalsFolder()
	local matches = {}
	if not folder then return matches end

	local mode = modes[currentModeIndex]
	local wantedDisplay = (#Brainrots > 0) and Brainrots[nameIndex].DisplayName or nil
	local pMin = tonumber(priceMin.Text)
	local gMin = tonumber(genMin.Text)

	for _, model in ipairs(folder:GetChildren()) do
		if model:IsA("Model") then
			local data = getDataForModel(model.Name)
			if data then
				local keep = false
				if mode == "Display Name" then
					keep = (model.Name == wantedDisplay)
				elseif mode == "Price ≥" then
					keep = (data.Price ~= nil and pMin ~= nil and data.Price >= pMin)
				elseif mode == "Generation ≥" then
					keep = (data.Generation ~= nil and gMin ~= nil and data.Generation >= gMin)
				end
				if keep then table.insert(matches, model) end
			end
		end
	end

	return matches
end

-- ===== UI: show matches =====
local function clearMatches()
	for _, child in ipairs(scrollFrame:GetChildren()) do
		if child:IsA("TextLabel") then child:Destroy() end
	end
end

function updateDisplay()
	clearMatches()
	local folder = getAnimalsFolder()
	if not folder then
		local lab = Instance.new("TextLabel")
		lab.Size = UDim2.new(1, -10, 0, 20)
		lab.BackgroundTransparency = 1
		lab.Text = RENDERED_FOLDER_NAME .. " not found"
		lab.TextColor3 = Color3.new(1, 1, 1)
		lab.Font = Enum.Font.SourceSans
		lab.TextSize = 14
		lab.TextXAlignment = Enum.TextXAlignment.Left
		lab.Parent = scrollFrame
		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 25)
		warningLabel.Visible = false
		return
	end

	local matches = collectMatches()
	local total = 0
	for _, model in ipairs(matches) do
		local data = getDataForModel(model.Name)
		local info
		if data then
			info = string.format("%s | %s | $%s | gen: %s",
				data.DisplayName,
				tostring(data.Rarity or "?"),
				tostring(data.Price or "?"),
				tostring(data.Generation or "?")
			)
		else
			info = model.Name
		end

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, -10, 0, 20)
		label.BackgroundTransparency = 1
		label.Text = info
		label.TextColor3 = Color3.new(1, 1, 1)
		label.Font = Enum.Font.SourceSans
		label.TextSize = 14
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.Parent = scrollFrame
		total += 25
	end
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, total)
	warningLabel.Visible = (#matches > 0)
	warningLabel.Text = (#matches > 0) and ("Matches: "..#matches) or ""
end

-- Live refresh on numeric inputs
local function onAnyChange()
	updateDisplay()
end
priceMin:GetPropertyChangedSignal("Text"):Connect(onAnyChange)
genMin:GetPropertyChangedSignal("Text"):Connect(onAnyChange)

-- Initial render
updateDisplay()

-- Find & lock nearest match
findBtn.MouseButton1Click:Connect(function()
	local matches = collectMatches()
	if #matches == 0 then
		warningLabel.Visible = true
		warningLabel.Text = "No matches."
		return
	end
	local target = nearestOf(matches)
	if target then
		lastTarget = target
		warningLabel.Visible = true
		warningLabel.Text = "Locked: " .. target.Name
	else
		warningLabel.Visible = true
		warningLabel.Text = "No target."
	end
end)

-- Periodic refresh
RunService.Heartbeat:Connect(function()
	if tick() % 0.5 < 0.1 then
		updateDisplay()
	end
end)

-- Follow loop
task.spawn(function()
	while true do
		task.wait(0.15)
		if gui.Enabled and autoEnabled and lastTarget then
			moveToTarget(lastTarget)
		end
	end
end)

-- Hold E loop when close
task.spawn(function()
	while true do
		task.wait(0.2)
		if not (gui.Enabled and autoEnabled and lastTarget) then
			if holdingE then pcall(function() VIM:SendKeyEvent(false, Enum.KeyCode.E, false, nil) end); holdingE=false end
			continue
		end
		local _, hrp = getCharParts()
		if not hrp or not lastTarget.Parent or not lastTarget.PrimaryPart then continue end
		local dist = (lastTarget.PrimaryPart.Position - hrp.Position).Magnitude
		if dist <= 10 then
			triggerNearbyPrompt(15)
			holdE(4.05)
		end
	end
end)
